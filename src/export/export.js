const AdmZip = require('adm-zip');
const fs = require('fs');
const glob = require('glob');
const ncp = require('ncp');
const path = require('path');
const rimraf = require('rimraf');
const tmp = require('tmp');

const api = require('../utils/api');
const { log } = require('../utils/log');
const {
  default: getProjectContent,
} = require('../utils/project-content/get-project-content');
const {
  default: writeProjectContent,
} = require('../utils/project-content/write-project-content');
const exportCollections = require('./export-legacy');

const ZIP_PATHS = [
  'fragments',
  'master-pages',
  'page-templates',
  'display-page-templates',
];

const ZIP_FRAGMENT_COLLECTION_DIRECTORY_NAME = [
  'fragments',
  'fragment-compositions',
];

/**
 * @param {string} groupId
 * @param {string} destinationPath
 */
async function exportProject(groupId, destinationPath) {
  const projectContent = getProjectContent(destinationPath);
  const tmpDir = tmp.dirSync({ unsafeCleanup: true });
  const tmpSrc = path.join(tmpDir.name, 'src');

  try {
    new AdmZip(await api.exportZip(groupId)).extractAllTo(tmpDir.name);
    fs.mkdirSync(tmpSrc);

    // Move generated categories (fragments, page-templates...) to a
    // single src directory

    for (const from of ZIP_PATHS) {
      const fromBasePath = path.join(tmpDir.name, from);
      const toBasePath = path.join(tmpSrc);

      for (const fromPath of glob.sync(path.join(fromBasePath, '*'))) {
        // eslint-disable-next-line no-await-in-loop
        await move(fromPath, fromPath.replace(fromBasePath, toBasePath));
      }
    }

    // Move autogenerated subdirectories (like fragmentCollection/fragments/*)
    // one level up, as generator doesn't create them

    for (const collectionDirectoryName of ZIP_FRAGMENT_COLLECTION_DIRECTORY_NAME) {
      for (const collectionDirectoryPath of glob.sync(
        path.join(tmpSrc, '*', collectionDirectoryName)
      )) {
        for (const fragmentPath of glob.sync(
          path.join(collectionDirectoryPath, '*')
        )) {
          const fragmentName = fragmentPath.replace(
            collectionDirectoryPath,
            ''
          );

          // eslint-disable-next-line no-await-in-loop
          await move(
            fragmentPath,
            path.resolve(path.join(fragmentPath, '..', '..', fragmentName))
          );
        }

        rimraf.sync(collectionDirectoryPath);
      }
    }

    // Merge everything with existing project

    await move(
      path.join(tmpDir.name, 'src'),
      path.join(destinationPath, 'src')
    );

    log('Site succesfully exported', { level: 'success' });
  } catch (_) {
    log('Zip export error, using legacy export', { level: 'error' });

    projectContent.collections = await exportCollections(
      groupId,
      projectContent
    );

    writeProjectContent(projectContent.basePath, projectContent);
  }

  tmpDir.removeCallback();
}

/**
 * @param {string} fromPath
 * @param {string} toPath
 * @return {Promise<void>}
 */
function move(fromPath, toPath) {
  return new Promise((resolve, reject) => {
    ncp(fromPath, toPath, (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });
}

module.exports = exportProject;
